#!/usr/bin/perl

use strict;
use warnings;

use GD::Simple;
use Time::HiRes qw(usleep);

# define parameters
my $rl = -2;        # lower bound real
my $il = -1;        # lower bound imag
my $ru = +1;        # upper bound real
my $iu = +1;        # upper bound imag
my $pixelsize = 0.01;

# calculate parameters
my $ncols = int(( $ru - $rl ) / $pixelsize);
my $nrows = int(( $iu - $il ) / $pixelsize);

#print "$ncols, $nrows\n";

# create a new image
my $img = GD::Simple->new($ncols,$nrows);
$img->penSize(1,1);

# interation over all cols and rows of image
for (my $col = 0; $col <= $ncols; $col++)
{
    # calculate real part of complex number c
    my $cr = $rl + $col * $pixelsize;

    for (my $row = 0; $row <= $nrows; $row++)
    {
        # calculate imaginary part of complex number c
        my $ci = $il + $row * $pixelsize;

        # calculate mandelbrot iterations
        my $iter = mb_sequence($cr, $ci);
        my $rgb = color($iter);

        # Draw point
        $img->moveTo($col,$row);
        $img->fgcolor(@{$rgb});
        $img->line(1);
    }
}

# output to png data (STDOUT)
print $img->png;

# calculate the mandelbot series
sub mb_sequence
{
    # get the complex number the iteration has to be
    # calculated for
    my $cr = shift;
    my $ci = shift;

    # initialize some values
    my $zr = 0;     # real part of series
    my $zi = 0;     # imag part of series
    my $za2 = 0;    # square of abs value
    my $n = 0;      # iteration

    while( $za2 <= 4 && $n <= 240 )
    {
        $zr = $zr**2 - $zi**2 + $cr;
        $zi = 2 * $zr * $zi + $ci;
        $za2 = $zr**2 + $zi**2;
        $n++;
    }

    return $n;
}

# return rgb color values as a function of the iterations
sub color
{
    my $n = shift;
    my @rgb = GD::Simple->HSVtoRGB($n,255,255);
    return \@rgb;
}
